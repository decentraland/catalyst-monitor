<!DOCTYPE html>
<html>
  <head>
    <title>Catalyst Nodes Monitor</title>
    <link rel="stylesheet" href="style.css">
  </head>

  <body>
    <div id="root"></div>

    <script src="https://unpkg.com/react@16.12.0/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@16.12.0/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.26.0/babel.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@9"></script>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />

    <script src="servers.js"></script>
    <script src="time.js"></script>

    <script type="text/babel">
      class ServerMonitor extends React.Component {
        constructor(props) {
          super(props)

          this.state = {
            content: {},
            lambdas: {},
            comms: {},
            bff: {},
            bffHealth: 'Unknown',
            archipelago: {},
            archipelagoHealth: 'Unknown',
            contentFailedDeployments: "?",
            commsLayers: [],
            usersInServer: 0,
            commsIslands: [],
            health: {},
          }
        }
        componentDidMount() {
          this.getNodeStatus()
        }

        async getNodeStatus() {
          this.getServerStatus("content")
          this.getServerStatus("lambdas")
          this.getServerStatus("bff")
          this.getContentFailedDeployments()

          try {
            const res = await fetch(`${this.props.address}/about`)
            const data = await res.json()

            const commsHealth = {
              comms: 'Unknown',
              archipelago: 'Unknown',
            }
            const commsV2 = data && data.configurations && data.configurations.commsProtocol === 'v2'
            if (commsV2) {
              this.getServerStatus("comms")
              commsHealth.comms = data.comms.healthy ? 'Healthy' : 'Down'
            } else {
              commsHealth.archipelago = data.comms.healthy ? 'Healthy' : 'Down'
              this.setState({ archipelago: data.comms })
            }

            const bffHealth = res.status === 200 ? 'Healthy' : 'Down'
            this.setState({ health: {
              ...this.state.health,
              ...commsHealth,
              bff: bffHealth,
              content: data.content.healthy ? 'Healthy' : 'Down',
              lambda: data.lambdas.healthy ? 'Healthy' : 'Down',
            }})
          } catch (err) {
            console.log(err)
            this.getServerStatus("comms")
            this.getServerHealth()
          }
        }

        getServerHealth() {
          fetch(`${this.props.address}/about`)
            .then((res) => res.json())
            .then((data) => {
              this.setState({ health: {
                ...this.state.health,
                ...data,
              } })
            })
            .catch(error => {
              console.log('/about endpoint is not already implemented, using lambdas/health instead')

              fetch(`${this.props.address}/lambdas/health`)
                .then((res) => res.json())
                .then((data) => {
                  this.setState({ health: {
                    ...this.state.health,
                    ...data,
                  } })
                })
                .catch(console.log)
            })
        }

        getServerStatus(server) {
          fetch(`${this.props.address}/${server}/status?includeLayers=true`)
            .then((res) => {
              if (server === "bff") {
                const bffHealth = res.status === 200 ? 'Healthy' : 'Down'
                this.setState({ health: {
                  ...this.state.health,
                  bff: bffHealth
                } })
              }
              return res
            })
            .then((res) => res.json())
            .then((data) => {
              this.setState({ [server]: data })
              if (server == "content") {
                this.props.contributeCommitHash(data.commitHash)
              }
              if (server === "comms") {
                this.processCommsData(data)
              }
            })
            .catch(console.log)
        }

        getContentFailedDeployments() {
          fetch(`${this.props.address}/content/failed-deployments`)
            .then((res) => res.json())
            .then((data) => this.setState({ contentFailedDeployments: data }))
            .catch(console.log)
        }

        processCommsData(commsStatus) {
          let usersInServer
          if (commsStatus.layers) {
            usersInServer = commsStatus.layers.map((layer) => layer.usersCount).reduce((a, b) => a + b, 0)
            this.setState({ commsLayers: commsStatus.layers })
            delete commsStatus.layers
            this.setState({ comms: commsStatus })
          } else {
            usersInServer = commsStatus.usersCount
            this.fetchIslandsData()
          }

          this.setState({ usersInServer })
          this.props.contributeUsers(usersInServer)
        }

        fetchIslandsData() {
          fetch(`${this.props.address}/comms/islands`)
            .then((res) => res.json())
            .then((data) => {
              if (data.ok) this.setState({ commsIslands: data.islands })
            })
            .catch(console.error)
        }

        getGlobalHealth() {
          const healths = Object.values(this.state.health)
          if (healths.includes("Down")) return "Down"
          if (healths.includes("Unhealthy")) return "Unhealthy"
          return "Healthy"
        }

        getHealth(server) {
          return this.state.health[server] ? this.state.health[server] : "Unknown"
        }

        render() {
          let title = this.props.address
          let isHttps = false
          if (this.props.address.startsWith("https://")) {
            title = this.props.address.substring("https://".length)
            isHttps = true
          }
          let isStatusReceived = this.state.content.catalystVersion && this.state.lambdas.version && this.state.comms.version
          if (title === "peer-historical.decentraland.org") // Historical catalyst is content-only
            isStatusReceived = this.state.content.catalystVersion
          let globalHealth = this.getGlobalHealth()
          return (
            <div
              className={
                (this.props.expectedEthNetwork === "mainnet" ? "node-prd" : "node-dev") +
                (isHttps && isStatusReceived ? "" : " node-wrong") +
                " " +
                globalHealth.toLowerCase()
              }
            >
              <div className="node-title">{title}</div>
              <div className="server-node-users">
                # {this.state.comms.name}: {this.state.usersInServer}
              </div>
              <ContentServer
                status={this.state.content}
                address={this.props.address}
                failedDeployments={this.state.contentFailedDeployments}
                expectedEthNetwork={this.props.expectedEthNetwork}
                health={this.getHealth("content")}
              />
              <LambdasServer
                status={this.state.lambdas}
                address={this.props.address}
                health={this.getHealth("lambda")}
              />
              <CommsServer
                status={this.state.comms}
                address={this.props.address}
                layers={this.state.commsLayers}
                islands={this.state.commsIslands}
                health={this.getHealth("comms")}
              />
              <ArchipelagoServer
                address={this.props.address}
                status={this.state.archipelago}
                health={this.getHealth("archipelago")}
              />
              <BffServer
                address={this.props.address}
                status={this.state.bff}
                health={this.getHealth("bff")}
              />
            </div>
          )
        }
      }

      function ContentServer(props) {
        const clusterInfo = props.status.synchronizationStatus
        const expectedEthNetworkOk = props.status.ethNetwork === props.expectedEthNetwork
        let otherServers = 0

        return (
          <div
            className={"content " + props.health.toLowerCase()}
            onClick={() =>
              showFullStatus(props, "content", [{ name: "Failed Deployments", data: props.failedDeployments }])
            }
          >
            <b>Content v{props.status.catalystVersion}</b>
            <br />
            <b>State: {clusterInfo ? clusterInfo.synchronizationState : "Unknown"}</b>
            <br />
            <div>Hash: {shortHash(props.status.commitHash)}</div>
            {props.status.snapshot != null ? (
              <div>
                Snapshot:
                <div style={{ paddingLeft: "10px" }}>
                  Last Generated: {deltaTime(props.status.snapshot.lastUpdatedTime)} ago
                </div>
                {Object.keys(props.status.snapshot.entities).map((entity) => (
                  <div style={{ paddingLeft: "10px" }}>
                    {entity[0].toUpperCase() + entity.slice(1)}: {props.status.snapshot.entities[entity]}
                  </div>
                ))}
              </div>
            ) : (
              <div />
            )}
            <div>
              Failed:{" "}
              {Array.isArray(props.failedDeployments) ? props.failedDeployments.length : props.failedDeployments}
            </div>
            <div>{!expectedEthNetworkOk ? "Eth: " + props.status.ethNetwork : ""}</div>
          </div>
        )
      }

      function CommsServer(props) {
        const maxLayerName = Math.max(...props.layers.map((layer) => layer.name.length))
        const minifiedLayers = props.layers.map(
          (layer) => `${layer.name.padEnd(maxLayerName)}: ${layer.usersCount}/${layer.maxUsers}`
        )
        const islands = props.islands.map(
          (island) =>
            `${island.id} (${island.center.map((it) => Math.round(it)).join(", ")}): ${island.peers.length}/${
              island.maxPeers
            }`
        )
        const extraInfo = []
        if (minifiedLayers.length > 0) extraInfo.push({ name: "Layers", data: minifiedLayers })
        if (islands.length > 0) extraInfo.push({ name: "Islands", data: islands })
        return (
          <div
            className={"comms " + props.health.toLowerCase()}
            onClick={() => showFullStatus(props, "comms", extraInfo)}
          >
            <div>
              <b>Comms v2: v{props.status.env ? shortHash(props.status.env.catalystVersion) : "?"}</b>
            </div>
            <div>Hash: {props.status.env ? shortHash(props.status.env.commitHash) : "?"}</div>
            {props.islands.length > 0 ? <div>Islands: {props.islands.length}</div> : ""}
            {props.layers
              .filter((layer) => layer.usersCount > 0)
              .map((layer) => (
                <div>
                  {layer.name}: {layer.usersCount}/{layer.maxUsers}
                </div>
              ))}
          </div>
        )
      }

      function LambdasServer(props) {
        const expectedContentServerUrl = props.address + "/content"
        const currentContentServerUrl = props.status.contentServerUrl
        const contentServerUrlOk =
          currentContentServerUrl === expectedContentServerUrl ||
          currentContentServerUrl === expectedContentServerUrl + "/"
        const contentServerUrlStatus = contentServerUrlOk ? "OK" : `ERROR: ${currentContentServerUrl}`
        return (
          <div className={"lambdas " + props.health.toLowerCase()} onClick={() => showFullStatus(props, "lambdas", [])}>
            <b>Lambdas v{props.status.catalystVersion}</b>
            <div>Hash: {shortHash(props.status.commitHash)}</div>
            <div>{!contentServerUrlOk ? "CSU: " + contentServerUrlStatus : ""}</div>
          </div>
        )
      }

      function BffServer(props) {
        return (
          <div className={"bff " + props.health.toLowerCase()} onClick={() => showFullStatus(props, "bff", [])}>
            <b>BFF</b>
            <div>Hash: {shortHash(props.status.commitHash)}</div>
          </div>
        )
      }

      function ArchipelagoServer(props) {
        return (
          <div className={"archipelago " + props.health.toLowerCase()}>
            <b>Archipelago (comms v3)</b>
            <div>Hash: {props.status.env ? shortHash(props.status.env.commitHash) : "?"}</div>
          </div>
        )
      }
      
      function showFullStatus(props, server, extraInfos) {
        const statusUrl = server !== 'archipelago' ? `${props.address}/${server}/status` : `${props.address}/bff/cluster-status`
        const contentHtml =
          "<pre style='text-align:left'>" +
          `<div>Status: ${JSON.stringify(props.status, null, 2)}</div>` +
          extraInfos
            .map((extraInfo) => `<div>${extraInfo.name}: ${JSON.stringify(extraInfo.data, null, 2)}</div>`)
            .join() +
          "</pre>"
        Swal.fire({
          title: `<a href=${statusUrl}>${statusUrl}</a>`,
          html: contentHtml,
          width: 1000,
        })
      }





      class Servers extends React.Component {
        constructor(props) {
          super(props)
          this.state = {
            totalProductiveUsers: 0,
            totalDevUsers: 0,
            totalNonDAOMainnetUsers: 0,
            commitsHashesInfo: {},
            syncCheck: undefined,
          }
        }

        sumProductiveUsers(usersCount) {
          this.setState({ totalProductiveUsers: this.state.totalProductiveUsers + usersCount })
        }

        sumNonDAOMainnetUsers(usersCount) {
          this.setState({ totalNonDAOMainnetUsers: this.state.totalNonDAOMainnetUsers + usersCount })
        }

        sumDevUsers(usersCount) {
          this.setState({ totalDevUsers: this.state.totalDevUsers + usersCount })
        }

        async addCommitHash(commitHash) {
          if (!this.state.commitsHashesInfo[commitHash]) {
            this.setState({
              commitsHashesInfo: { ...this.state.commitsHashesInfo, [commitHash]: { hash: commitHash, count: 1 } },
            })
            const commitDate = await this.getCommitDate(commitHash)
            this.setState({
              commitsHashesInfo: {
                ...this.state.commitsHashesInfo,
                [commitHash]: { ...this.state.commitsHashesInfo[commitHash], date: commitDate },
              },
            })
          } else {
            this.setState({
              commitsHashesInfo: {
                ...this.state.commitsHashesInfo,
                [commitHash]: {
                  ...this.state.commitsHashesInfo[commitHash],
                  count: this.state.commitsHashesInfo[commitHash].count + 1,
                },
              },
            })
          }
        }

        async getCommitDate(commitHash) {
          try {
            const response = await fetch(`https://api.github.com/repos/decentraland/catalyst/commits/${commitHash}`)
            if (response.ok) {
              const data = await response.json()
              return new Date(data.commit.author.date)
            }
          } catch (error) {
            console.error(error)
          }
          return undefined
        }

        renderDAOMainnetServers() {
          return (
            <div>
              <div className="node-set">
                {DAOMainnetServers.map((server) => {
                  return (
                    <ServerMonitor
                      address={server}
                      expectedEthNetwork="mainnet"
                      contributeUsers={(usersCount) => this.sumProductiveUsers(usersCount)}
                      contributeCommitHash={(commitHash) => this.addCommitHash(commitHash)}
                    />
                  )
                })}
              </div>
              <div className="total-productive-users">Total Users: {this.state.totalProductiveUsers}</div>
            </div>
          )
        }

        renderExtraServers() {
          const currentUrl = window.location.href.toString()
          if (currentUrl.indexOf("includeDevServers") >= 0) {
            return (
              <div>
                <div className="node-set">
                  {nonDAOMainnetServers.map((server) => {
                    return (
                      <ServerMonitor
                        address={server}
                        expectedEthNetwork="mainnet"
                        contributeUsers={(usersCount) => this.sumNonDAOMainnetUsers(usersCount)}
                        contributeCommitHash={(commitHash) => this.addCommitHash(commitHash)}
                      />
                    )
                  })}
                </div>
                <div className="total-productive-users">Total Users: {this.state.totalNonDAOMainnetUsers}</div>
                <div className="node-set">
                  {zoneServers.map((server) => {
                    return (
                      <ServerMonitor
                        address={server}
                        expectedEthNetwork="ropsten"
                        contributeUsers={(usersCount) => this.sumDevUsers(usersCount)}
                        contributeCommitHash={(commitHash) => this.addCommitHash(commitHash)}
                      />
                    )
                  })}
                </div>
                <div className="total-dev-users">Total Users: {this.state.totalDevUsers}</div>
              </div>
            )
          } else {
            return <div />
          }
        }

        renderCommitHashesInfo() {
          const sortedCommits = Object.values(this.state.commitsHashesInfo)
          sortedCommits.sort((a, b) => b.date - a.date)
          return (
            <div className="commit-info-container">
              {sortedCommits.map((commitInfo) => {
                return (
                  <div className="commit-info">
                    <b>
                      <a href={`https://github.com/decentraland/catalyst/commit/${commitInfo.hash}`} target="_blank">
                        {shortHash(commitInfo.hash)}
                      </a>
                    </b>
                    : {toISOString(commitInfo.date)} ({deltaTime(commitInfo.date)}) ({commitInfo.count})
                  </div>
                )
              })}
            </div>
          )
        }

        /** Fetch all relevant timestamps for the given entities. We might need to make more than one request. */
        async checkEntityTimes(server, entities) {
          if (entities.size == 0) {
            return new Map()
          }

          const result = []
          const entitiesToFetch = [...entities]
          let url = `${server}/content/deployments?fields=auditInfo`
          for (let i = 0; i < entitiesToFetch.length; i++) {
            const newQueryParam = `&entityId=${entitiesToFetch[i]}`
            if (url.length + newQueryParam.length > 2048) {
              const response = await fetch(url)
              const { deployments } = await response.json()
              deployments
                .map(({ entityId, entityTimestamp, auditInfo }) => [
                  entityId,
                  { entityTimestamp, localTimestamp: auditInfo.localTimestamp },
                ])
                .forEach((entry) => result.push(entry))
              url = `${server}/content/deployments?fields=auditInfo`
            }
            url = url + newQueryParam
          }

          const response = await fetch(url)
          const { deployments } = await response.json()
          deployments
            .map(({ entityId, entityTimestamp, auditInfo }) => [
              entityId,
              { entityTimestamp, localTimestamp: auditInfo.localTimestamp },
            ])
            .forEach((entry) => result.push(entry))

          return new Map(result)
        }

        render() {
          return (
            <div>
              {this.renderDAOMainnetServers()}
              {this.renderExtraServers()}
              {this.renderCommitHashesInfo()}
            </div>
          )
        }
      }

      ReactDOM.render(<Servers />, document.getElementById("root"))
    </script>
  </body>
</html>
